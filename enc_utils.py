import base64
import os

from cryptography.exceptions import InvalidKey
from cryptography.hazmat.primitives.kdf.argon2 import Argon2id


def hash_password(password):
    """Hashes a password using Argon2 with the cryptography library."""
    # Generate a random salt
    salt = os.urandom(16)

    # Define Argon2 parameters (must be consistent between hash and verify)
    argon2_hasher = Argon2id(
        salt=salt,
        length=32,  # MUST match hash_password
        iterations=1,  # MUST match hash_password
        lanes=4,  # MUST match hash_password
        memory_cost=64 * 1024,  # MUST match hash_password
        ad=None,  # MUST match hash_password
        secret=None,  # MUST match hash_password
    )

    # Derive the key (hash)
    hash_bytes = argon2_hasher.derive(password.encode('utf-8'))

    # Encode both salt and hash for storage
    encoded_salt = base64.b64encode(salt).decode('utf-8')
    encoded_hash = base64.b64encode(hash_bytes).decode('utf-8')

    # Return combined hash and salt in a specific format
    return f"$argon2id${encoded_salt}${encoded_hash}"


# --- Fixed Verification Function ---
def verify_password(stored_hash_string, provided_password):
    """Verifies a provided password against a stored Argon2id hash string.

    Args:
        stored_hash_string: The hash string generated by hash_password
                            (format: $argon2id$encoded_salt$encoded_hash).
        provided_password: The plain-text password attempt to verify.

    Returns:
        True if the provided password matches the stored hash, False otherwise.
    """
    try:
        # 1. Parse the stored string to extract salt and hash
        parts = stored_hash_string.split('$')
        if len(parts) != 4 or parts[1] != 'argon2id':
            print("Error: Invalid hash string format.")
            return False  # Invalid format

        encoded_salt = parts[2]
        encoded_hash = parts[3]

        # 2. Decode the salt and the stored hash
        salt = base64.b64decode(encoded_salt)
        stored_hash_bytes = base64.b64decode(encoded_hash)

        # 3. Re-create the Argon2 hasher with the same parameters
        #    as used in hash_password, but using the extracted salt
        argon2_hasher = Argon2id(
            salt=salt,
            length=32,  # MUST match hash_password
            iterations=1,  # MUST match hash_password
            lanes=4,  # MUST match hash_password
            memory_cost=64 * 1024,  # MUST match hash_password
            ad=None,  # MUST match hash_password
            secret=None,  # MUST match hash_password
        )

        # 4. Derive the key from the provided password
        derived_key = argon2_hasher.derive(provided_password.encode('utf-8'))

        # 5. Compare the derived key with the stored hash
        # This comparison needs to be constant-time to avoid timing attacks
        return derived_key == stored_hash_bytes

    except (ValueError, IndexError) as e:
        # Handle errors during splitting, decoding, etc.
        print(f"Error during verification (invalid format or data): {e}")
        return False
    except Exception as e:
        # Catch any other unexpected errors during verification
        print(f"An unexpected error occurred during verification: {e}")
        return False


if __name__ == '__main__':
    hashed = hash_password("key")
    print(hashed)
    print(verify_password(hashed, "key"))
